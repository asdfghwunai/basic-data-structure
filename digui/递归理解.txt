-----框架的设计------
只要当前问题的解决依赖于后面子问题的解决都能用递归来写(你这意思是后序)

递归就是这次只解决一小部分，然后转移到下次递归让他们解决（你这意思又是前序）
(原则是先解决孩子，再解决自己（当延迟）,要么先解决自己再解决孩子（当超前），归并是先解决孩子，快排是先解决自己，还有前序和后序遍历)

-----参数类型选择-------
形参是引用是所有递归共用一个变量，如果是自己独有就用实体或指针(指针用数组名它就是公用的，比如归并或快排里的数组名；只是一个小变量，它就是私用的，比如二叉树遍历。。指针介于实体和引用之间)
考虑好哪些变量是全局的，全局的就用引用，不是全局的就用指针和实体

-----深入的理解-------
递归的处理函数必须是统一的，比如中序，前序，后序都是统一的输出一下，如果有分歧就说明递归设计的不合理

在一个函数中（比如中序），前半段递归函数执行完就说明处理好了，后半段还没执行就说明没处理好（从二叉搜索树转为双向链表看出来）

一般刚开始要判断异常条件的都要再写个递归函数处理，比如二叉搜索树的第k个结点你刚开始要判断，递归函数另外设计
if(pRoot==NULL||k==0)
       return NULL;  就不能直接把函数头当递归
       
突然发现递归的返回只是返回给上一层，让上一层用，不是直接返回结果(从归并两个排序链表)
       
通过回溯对递归理解又精进一点:
回溯就是有条件前序遍历，回溯的递归起点有很多个，这些起点没联系，所以才要for循环驱动；
而二叉树遍历就只有一个起点，所以不用for循环，但是建立是一个一个驱动的；而非连通图在使用dfs或bfs时就要有for驱动了
