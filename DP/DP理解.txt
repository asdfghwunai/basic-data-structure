
=======二维数组===========
注意初始化为 dp[N+1][V+1],N和V分别为行数组和列数组的元素个数
行是种类数，是不连续的；列是容量，是连续的

------0,1背包问题-------//突然发现i,j只是坐标，而里面的元素是答案
1.转移方程为 
dp[i][j]=max{dp[i-1][j],dp[i-1][j-v[i]]+c[i]}  
//注意不是从i行转移来的，因为列表示容量，一行的4容量最优和3容量最优没关系，就是本行的3容量最优不一定是4容量最优，而决定的是现在这个时刻装不装，
装的话就是(不装的最优状态+增加的价值)，dp[i][j-v[i]]不一定没装，而dp[i-1][j-v[i]]一定没装
你就把i行当成不同时刻即可

-------最长公共子串-------串是连续的
1.转移方程为
if(str1[i]==str2[j])     //相等就由左上角转移过来
  dp[i][j]=dp[i-1][j-1]+1;
else
  dp[i][j]=0;
  

-------最长公共子序列-------子序列是不连续的
if(str1[i]==str2[j])     //相等就由左上角转移过来
  dp[i][j]=dp[i-1][j-1]+1;
else
  dp[i][j]=max{dp[i][j-1],dp[i-1][j]};  //不相等就看左边或上边

======一维数组==========
初始化数组为 dp[N+1]
不知为啥，双重for循环就从尾到头，见https://blog.csdn.net/u014490454/article/details/77990195
这个看成一个for循环，http://www.cnblogs.com/tgycoder/p/5034131.html
但好像正着来反着来都行，见https://blog.csdn.net/qq_34369618/article/details/72852740

------最长递增子序列长度/最长递增子串-------连不连续都行，感觉乱叫
1.转移方程为
dp[0]=0;
dp[x]=max{1,dp[i]+1 for all i<x&&a[i]<a[x]}


------最大子序列和---------
1.转移方程为
dp[i]=max{a[i],di[i-1]+a[i]}  //反正ai必须有,如果前面的状态有帮助就要了，不然还不如只要自己，我感觉一切都假设已经得到最优解前面

-----连续子数组的最大和--------必须连续的，可以用那种方法，弄个sum和max变量

------求最大连续递增数字串长度和样子----也是连续的，也是两个变量，newlen和maxlen，用到记录和清空（遇到不符合要求）

-----最长不重复子串长度----用到哈希表记录上次出现的位置
pre=max(pre,mp[s[i]]);   //pre是最近无重复的开头位置，mp[s[i]]是第i个字符的位置
maxlen=max(maxlen,i-pre)


